<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pynever.datasets API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pynever.datasets</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import abc
import numpy as np
import torchvision as tv
import torch.utils.data as tdata
from typing import Callable, Optional, Tuple, Any


class Dataset(abc.ABC):
    &#34;&#34;&#34;
    An abstract class used to represent a Dataset. The concrete descendant must implement the methods __getitem__ and
    __len__.

    &#34;&#34;&#34;

    @abc.abstractmethod
    def __getitem__(self, index: int):
        raise NotImplementedError

    @abc.abstractmethod
    def __len__(self):
        raise NotImplementedError


class TorchMNIST(Dataset, tv.datasets.MNIST):
    &#34;&#34;&#34;
    A concrete class used to represent the MNIST Dataset. It leverage the torch dataset MNIST.

    Attributes
    ----------
    data_path : str
        Path to the folder in which the dataset will be saved.
    train : bool
        If True then the training set is loaded otherwise the test set is loaded.
    transform : Callable, Optional
        Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
        The parameters of the callable (other than the object subject to the transformation) should be attributes of
        the object.
    target_transform : Callable, Optional
        Transformation to apply to the targets. We assume this is an object like the transforms presented in
        torchvision. The parameters of the callable (other than the object subject to the transformation) should be
        attributes of the object.
    download : bool
        True if the dataset must be downloaded, False otherwise.

    &#34;&#34;&#34;

    def __init__(self, data_path: str, train: bool, transform: Optional[Callable] = None,
                 target_transform: Optional[Callable] = None, download: bool = True):

        Dataset.__init__(self)
        tv.datasets.MNIST.__init__(self, data_path, train, transform, target_transform, download)

    def __getitem__(self, index: int):
        return tv.datasets.MNIST.__getitem__(self, index)

    def __len__(self):
        return tv.datasets.MNIST.__len__(self)


class TorchFMNIST(Dataset, tv.datasets.FashionMNIST):
    &#34;&#34;&#34;
    A concrete class used to represent the FMNIST Dataset. It leverage the torch dataset FMNIST.

    Attributes
    ----------
    data_path : str
        Path to the folder in which the dataset will be saved.
    train : bool
        If True then the training set is loaded otherwise the test set is loaded.
    transform : Callable, Optional
        Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
        The parameters of the callable (other than the object subject to the transformation) should be attributes of
        the object.
    target_transform : Callable, Optional
        Transformation to apply to the targets. We assume this is an object like the transforms presented in
        torchvision. The parameters of the callable (other than the object subject to the transformation) should be
        attributes of the object.
    download : bool
        True if the dataset must be downloaded, False otherwise.

    &#34;&#34;&#34;

    def __init__(self, data_path: str, train: bool, transform: Optional[Callable] = None,
                 target_transform: Optional[Callable] = None, download: bool = True):
        Dataset.__init__(self)
        tv.datasets.FashionMNIST.__init__(self, data_path, train, transform, target_transform, download)

    def __getitem__(self, index: int):
        return tv.datasets.FashionMNIST.__getitem__(self, index)

    def __len__(self):
        return tv.datasets.FashionMNIST.__len__(self)


class GenericFileDataset(Dataset, tdata.Dataset):
    &#34;&#34;&#34;
    A concrete class used to represent a generic dataset memorized as a txt file. It loads the values using numpy
    loadtxt function. It assumes each line of the file is a separated datapoint.
    For each line we assume that the first n values are the input and the following are the target. The index of the
    first element of the target is identified by the target_index attribute.

    Attributes
    ----------
    filepath : str
        Path to the file containing the dataset.
        N.B.: the names of the dataset are supposed to be jame_pos_*.txt where * can be test or train.
    target_index : int
        Index of the first element of the outputs.
    dtype : type, Optional
        Data type of the values of the datapoints. Refer to numpy.loadtxt for more details.
    delimiter : str, Optional
        Delimiter between the different values of the datapoints. Refer to numpy.loadtxt for more details.
    transform : Callable, Optional
        Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
        The parameters of the callable (other than the object subject to the transformation) should be attributes of
        the object.
    target_transform : Callable, Optional
        Transformation to apply to the targets. We assume this is an object like the transforms presented in
        torchvision. The parameters of the callable (other than the object subject to the transformation) should be
        attributes of the object.

    &#34;&#34;&#34;

    def __init__(self, filepath: str, target_index: int, dtype: type = float, delimiter: str = &#34;,&#34;,
                 transform: Callable = None, target_transform: Callable = None):

        self.filepath = filepath
        self.target_index = target_index
        self.dtype = dtype
        self.delimiter = delimiter
        self.transform = transform
        self.target_transform = target_transform

        dataset = np.loadtxt(filepath, dtype=self.dtype, delimiter=self.delimiter)

        self.__data, self.__targets = (dataset[:, 0:self.target_index], dataset[:, self.target_index:])

    def __getitem__(self, index: int) -&gt; Tuple[Any, Any]:

        data, target = self.__data[index], self.__targets[index]
        if self.transform is not None:
            data = self.transform(data)
        if self.target_transform is not None:
            target = self.target_transform(target)

        return data, target

    def __len__(self):
        return len(self.__data)


class DynamicsJamesPos(GenericFileDataset, tdata.Dataset):
    &#34;&#34;&#34;
    A concrete class used to represent the Dynamic James Dataset presented in the paper
    &#34;Challenging SMT solvers to verify neural networks&#34; by Pulina and Tacchella (2012).
    Automatic download is at present not supported, therefore the dataset must be downloaded manually.

    Attributes
    ----------
    data_path : str
        Path to the folder containing the training set and the test set.
        N.B.: the names of the dataset are supposed to be james_pos_*.txt where * can be test or train.
    train : bool
        If True then the training set is loaded otherwise the test set is loaded.
    transform : Callable, Optional
        Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
        The parameters of the callable (other than the object subject to the transformation) should be attributes of
        the object.
    target_transform : Callable, Optional
        Transformation to apply to the targets. We assume this is an object like the transforms presented in
        torchvision. The parameters of the callable (other than the object subject to the transformation) should be
        attributes of the object.

    &#34;&#34;&#34;

    def __init__(self, data_path: str, train: bool, transform: Optional[Callable] = None,
                 target_transform: Optional[Callable] = None):

        tdata.Dataset.__init__(self)

        if train:
            dataset_path = data_path + &#34;james_pos_train.txt&#34;
        else:
            dataset_path = data_path + &#34;james_pos_test.txt&#34;

        GenericFileDataset.__init__(self, dataset_path, 8, transform=transform, target_transform=target_transform)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pynever.datasets.Dataset"><code class="flex name class">
<span>class <span class="ident">Dataset</span></span>
</code></dt>
<dd>
<div class="desc"><p>An abstract class used to represent a Dataset. The concrete descendant must implement the methods <strong>getitem</strong> and
<strong>len</strong>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dataset(abc.ABC):
    &#34;&#34;&#34;
    An abstract class used to represent a Dataset. The concrete descendant must implement the methods __getitem__ and
    __len__.

    &#34;&#34;&#34;

    @abc.abstractmethod
    def __getitem__(self, index: int):
        raise NotImplementedError

    @abc.abstractmethod
    def __len__(self):
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pynever.datasets.GenericFileDataset" href="#pynever.datasets.GenericFileDataset">GenericFileDataset</a></li>
<li><a title="pynever.datasets.TorchFMNIST" href="#pynever.datasets.TorchFMNIST">TorchFMNIST</a></li>
<li><a title="pynever.datasets.TorchMNIST" href="#pynever.datasets.TorchMNIST">TorchMNIST</a></li>
</ul>
</dd>
<dt id="pynever.datasets.DynamicsJamesPos"><code class="flex name class">
<span>class <span class="ident">DynamicsJamesPos</span></span>
<span>(</span><span>data_path: str, train: bool, transform: Union[Callable, NoneType] = None, target_transform: Union[Callable, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A concrete class used to represent the Dynamic James Dataset presented in the paper
"Challenging SMT solvers to verify neural networks" by Pulina and Tacchella (2012).
Automatic download is at present not supported, therefore the dataset must be downloaded manually.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the folder containing the training set and the test set.
N.B.: the names of the dataset are supposed to be james_pos_*.txt where * can be test or train.</dd>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True then the training set is loaded otherwise the test set is loaded.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>Callable, Optional</code></dt>
<dd>Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
The parameters of the callable (other than the object subject to the transformation) should be attributes of
the object.</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>Callable, Optional</code></dt>
<dd>Transformation to apply to the targets. We assume this is an object like the transforms presented in
torchvision. The parameters of the callable (other than the object subject to the transformation) should be
attributes of the object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynamicsJamesPos(GenericFileDataset, tdata.Dataset):
    &#34;&#34;&#34;
    A concrete class used to represent the Dynamic James Dataset presented in the paper
    &#34;Challenging SMT solvers to verify neural networks&#34; by Pulina and Tacchella (2012).
    Automatic download is at present not supported, therefore the dataset must be downloaded manually.

    Attributes
    ----------
    data_path : str
        Path to the folder containing the training set and the test set.
        N.B.: the names of the dataset are supposed to be james_pos_*.txt where * can be test or train.
    train : bool
        If True then the training set is loaded otherwise the test set is loaded.
    transform : Callable, Optional
        Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
        The parameters of the callable (other than the object subject to the transformation) should be attributes of
        the object.
    target_transform : Callable, Optional
        Transformation to apply to the targets. We assume this is an object like the transforms presented in
        torchvision. The parameters of the callable (other than the object subject to the transformation) should be
        attributes of the object.

    &#34;&#34;&#34;

    def __init__(self, data_path: str, train: bool, transform: Optional[Callable] = None,
                 target_transform: Optional[Callable] = None):

        tdata.Dataset.__init__(self)

        if train:
            dataset_path = data_path + &#34;james_pos_train.txt&#34;
        else:
            dataset_path = data_path + &#34;james_pos_test.txt&#34;

        GenericFileDataset.__init__(self, dataset_path, 8, transform=transform, target_transform=target_transform)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynever.datasets.GenericFileDataset" href="#pynever.datasets.GenericFileDataset">GenericFileDataset</a></li>
<li><a title="pynever.datasets.Dataset" href="#pynever.datasets.Dataset">Dataset</a></li>
<li>abc.ABC</li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pynever.datasets.GenericFileDataset"><code class="flex name class">
<span>class <span class="ident">GenericFileDataset</span></span>
<span>(</span><span>filepath: str, target_index: int, dtype: type = builtins.float, delimiter: str = ',', transform: Callable = None, target_transform: Callable = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A concrete class used to represent a generic dataset memorized as a txt file. It loads the values using numpy
loadtxt function. It assumes each line of the file is a separated datapoint.
For each line we assume that the first n values are the input and the following are the target. The index of the
first element of the target is identified by the target_index attribute.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file containing the dataset.
N.B.: the names of the dataset are supposed to be jame_pos_*.txt where * can be test or train.</dd>
<dt><strong><code>target_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the first element of the outputs.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type, Optional</code></dt>
<dd>Data type of the values of the datapoints. Refer to numpy.loadtxt for more details.</dd>
<dt><strong><code>delimiter</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>Delimiter between the different values of the datapoints. Refer to numpy.loadtxt for more details.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>Callable, Optional</code></dt>
<dd>Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
The parameters of the callable (other than the object subject to the transformation) should be attributes of
the object.</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>Callable, Optional</code></dt>
<dd>Transformation to apply to the targets. We assume this is an object like the transforms presented in
torchvision. The parameters of the callable (other than the object subject to the transformation) should be
attributes of the object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericFileDataset(Dataset, tdata.Dataset):
    &#34;&#34;&#34;
    A concrete class used to represent a generic dataset memorized as a txt file. It loads the values using numpy
    loadtxt function. It assumes each line of the file is a separated datapoint.
    For each line we assume that the first n values are the input and the following are the target. The index of the
    first element of the target is identified by the target_index attribute.

    Attributes
    ----------
    filepath : str
        Path to the file containing the dataset.
        N.B.: the names of the dataset are supposed to be jame_pos_*.txt where * can be test or train.
    target_index : int
        Index of the first element of the outputs.
    dtype : type, Optional
        Data type of the values of the datapoints. Refer to numpy.loadtxt for more details.
    delimiter : str, Optional
        Delimiter between the different values of the datapoints. Refer to numpy.loadtxt for more details.
    transform : Callable, Optional
        Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
        The parameters of the callable (other than the object subject to the transformation) should be attributes of
        the object.
    target_transform : Callable, Optional
        Transformation to apply to the targets. We assume this is an object like the transforms presented in
        torchvision. The parameters of the callable (other than the object subject to the transformation) should be
        attributes of the object.

    &#34;&#34;&#34;

    def __init__(self, filepath: str, target_index: int, dtype: type = float, delimiter: str = &#34;,&#34;,
                 transform: Callable = None, target_transform: Callable = None):

        self.filepath = filepath
        self.target_index = target_index
        self.dtype = dtype
        self.delimiter = delimiter
        self.transform = transform
        self.target_transform = target_transform

        dataset = np.loadtxt(filepath, dtype=self.dtype, delimiter=self.delimiter)

        self.__data, self.__targets = (dataset[:, 0:self.target_index], dataset[:, self.target_index:])

    def __getitem__(self, index: int) -&gt; Tuple[Any, Any]:

        data, target = self.__data[index], self.__targets[index]
        if self.transform is not None:
            data = self.transform(data)
        if self.target_transform is not None:
            target = self.target_transform(target)

        return data, target

    def __len__(self):
        return len(self.__data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynever.datasets.Dataset" href="#pynever.datasets.Dataset">Dataset</a></li>
<li>abc.ABC</li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pynever.datasets.DynamicsJamesPos" href="#pynever.datasets.DynamicsJamesPos">DynamicsJamesPos</a></li>
</ul>
</dd>
<dt id="pynever.datasets.TorchFMNIST"><code class="flex name class">
<span>class <span class="ident">TorchFMNIST</span></span>
<span>(</span><span>data_path: str, train: bool, transform: Union[Callable, NoneType] = None, target_transform: Union[Callable, NoneType] = None, download: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>A concrete class used to represent the FMNIST Dataset. It leverage the torch dataset FMNIST.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the folder in which the dataset will be saved.</dd>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True then the training set is loaded otherwise the test set is loaded.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>Callable, Optional</code></dt>
<dd>Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
The parameters of the callable (other than the object subject to the transformation) should be attributes of
the object.</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>Callable, Optional</code></dt>
<dd>Transformation to apply to the targets. We assume this is an object like the transforms presented in
torchvision. The parameters of the callable (other than the object subject to the transformation) should be
attributes of the object.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the dataset must be downloaded, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TorchFMNIST(Dataset, tv.datasets.FashionMNIST):
    &#34;&#34;&#34;
    A concrete class used to represent the FMNIST Dataset. It leverage the torch dataset FMNIST.

    Attributes
    ----------
    data_path : str
        Path to the folder in which the dataset will be saved.
    train : bool
        If True then the training set is loaded otherwise the test set is loaded.
    transform : Callable, Optional
        Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
        The parameters of the callable (other than the object subject to the transformation) should be attributes of
        the object.
    target_transform : Callable, Optional
        Transformation to apply to the targets. We assume this is an object like the transforms presented in
        torchvision. The parameters of the callable (other than the object subject to the transformation) should be
        attributes of the object.
    download : bool
        True if the dataset must be downloaded, False otherwise.

    &#34;&#34;&#34;

    def __init__(self, data_path: str, train: bool, transform: Optional[Callable] = None,
                 target_transform: Optional[Callable] = None, download: bool = True):
        Dataset.__init__(self)
        tv.datasets.FashionMNIST.__init__(self, data_path, train, transform, target_transform, download)

    def __getitem__(self, index: int):
        return tv.datasets.FashionMNIST.__getitem__(self, index)

    def __len__(self):
        return tv.datasets.FashionMNIST.__len__(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynever.datasets.Dataset" href="#pynever.datasets.Dataset">Dataset</a></li>
<li>abc.ABC</li>
<li>torchvision.datasets.mnist.FashionMNIST</li>
<li>torchvision.datasets.mnist.MNIST</li>
<li>torchvision.datasets.vision.VisionDataset</li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pynever.datasets.TorchMNIST"><code class="flex name class">
<span>class <span class="ident">TorchMNIST</span></span>
<span>(</span><span>data_path: str, train: bool, transform: Union[Callable, NoneType] = None, target_transform: Union[Callable, NoneType] = None, download: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>A concrete class used to represent the MNIST Dataset. It leverage the torch dataset MNIST.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the folder in which the dataset will be saved.</dd>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True then the training set is loaded otherwise the test set is loaded.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>Callable, Optional</code></dt>
<dd>Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
The parameters of the callable (other than the object subject to the transformation) should be attributes of
the object.</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>Callable, Optional</code></dt>
<dd>Transformation to apply to the targets. We assume this is an object like the transforms presented in
torchvision. The parameters of the callable (other than the object subject to the transformation) should be
attributes of the object.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the dataset must be downloaded, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TorchMNIST(Dataset, tv.datasets.MNIST):
    &#34;&#34;&#34;
    A concrete class used to represent the MNIST Dataset. It leverage the torch dataset MNIST.

    Attributes
    ----------
    data_path : str
        Path to the folder in which the dataset will be saved.
    train : bool
        If True then the training set is loaded otherwise the test set is loaded.
    transform : Callable, Optional
        Transformation to apply to the data. We assume this is an object like the transforms presented in torchvision.
        The parameters of the callable (other than the object subject to the transformation) should be attributes of
        the object.
    target_transform : Callable, Optional
        Transformation to apply to the targets. We assume this is an object like the transforms presented in
        torchvision. The parameters of the callable (other than the object subject to the transformation) should be
        attributes of the object.
    download : bool
        True if the dataset must be downloaded, False otherwise.

    &#34;&#34;&#34;

    def __init__(self, data_path: str, train: bool, transform: Optional[Callable] = None,
                 target_transform: Optional[Callable] = None, download: bool = True):

        Dataset.__init__(self)
        tv.datasets.MNIST.__init__(self, data_path, train, transform, target_transform, download)

    def __getitem__(self, index: int):
        return tv.datasets.MNIST.__getitem__(self, index)

    def __len__(self):
        return tv.datasets.MNIST.__len__(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynever.datasets.Dataset" href="#pynever.datasets.Dataset">Dataset</a></li>
<li>abc.ABC</li>
<li>torchvision.datasets.mnist.MNIST</li>
<li>torchvision.datasets.vision.VisionDataset</li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pynever" href="index.html">pynever</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pynever.datasets.Dataset" href="#pynever.datasets.Dataset">Dataset</a></code></h4>
</li>
<li>
<h4><code><a title="pynever.datasets.DynamicsJamesPos" href="#pynever.datasets.DynamicsJamesPos">DynamicsJamesPos</a></code></h4>
</li>
<li>
<h4><code><a title="pynever.datasets.GenericFileDataset" href="#pynever.datasets.GenericFileDataset">GenericFileDataset</a></code></h4>
</li>
<li>
<h4><code><a title="pynever.datasets.TorchFMNIST" href="#pynever.datasets.TorchFMNIST">TorchFMNIST</a></code></h4>
</li>
<li>
<h4><code><a title="pynever.datasets.TorchMNIST" href="#pynever.datasets.TorchMNIST">TorchMNIST</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>